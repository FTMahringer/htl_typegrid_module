name: Version Update and Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'release = Y.(X+1).0 | vUpgrade = (Y+1).0.0'
        required: true
        default: 'release'
        type: choice
        options: [release, vUpgrade]
  push:
    branches: [ main, master ]
    paths-ignore:
      - '**.md'

permissions:
  contents: write

jobs:
  versioning:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # alle Tags

      - name: Ensure gh cli present
        run: |
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi

      - name: Detect release type (dispatch or commit message)
        id: mode
        run: |
          TYPE="${{ github.event.inputs.release_type }}"
          if [ "${{ github.event_name }}" = "push" ]; then
            MSG="${{ github.event.head_commit.message }}"
            if echo "$MSG" | grep -qi -- "-vUpgrade"; then
              TYPE="vUpgrade"
            elif echo "$MSG" | grep -qi -- "-release"; then
              TYPE="release"
            fi
          fi
          [ -z "$TYPE" ] && TYPE="release"
          echo "release_type=$TYPE" >> "$GITHUB_OUTPUT"
          echo "Using release_type=$TYPE"

      - name: Compute next SemVer and outputs
        id: version
        env:
          RELEASE_TYPE: ${{ steps.mode.outputs.release_type }}
        shell: bash
        run: |
          # Alle Tags holen
          git fetch --tags --force

          # Alle Tags in X.Y.Z normalisieren (ohne führendes v), nur echte SemVer
          mapfile -t versions < <(git tag --list | sed -E 's/^v//' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V)
          last="0.0.0"
          if [ ${#versions[@]} -gt 0 ]; then
            last="${versions[-1]}"
          fi

          IFS='.' read -r MA MI PA <<<"$last"

          if [ "$RELEASE_TYPE" = "vUpgrade" ]; then
            NEW="$((MA+1)).0.0"
          else
            NEW="${MA}.$((MI+1)).0"
          fi

          echo "last_version=$last"
          echo "new_version=$NEW"

          echo "last_version=$last" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW" >> "$GITHUB_OUTPUT"
          echo "tag_v=v$NEW" >> "$GITHUB_OUTPUT"

      - name: Configure Git author
        run: |
          git config user.name  "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

      - name: Remove version from composer.json (Composer derives from tags)
        run: |
          if [ -f composer.json ]; then
            sudo apt-get update -y && sudo apt-get install -y jq
            # Entfernt das Feld .version, falls vorhanden
            tmp=$(mktemp)
            jq 'del(.version)' composer.json > "$tmp" && mv "$tmp" composer.json
            if git diff --quiet -- composer.json; then
              echo "composer.json unverändert (kein .version Feld)."
            else
              git add composer.json
              git commit -m "chore: remove composer.json version (use git tags)"
              git push
            fi
          else
            echo "composer.json nicht gefunden – überspringe."
          fi

      - name: Create annotated SemVer tag (with v prefix)
        env:
          TAG_V: ${{ steps.version.outputs.tag_v }}
        run: |
          if git rev-parse "refs/tags/${TAG_V}" >/dev/null 2>&1; then
            echo "Tag ${TAG_V} existiert bereits – überspringe."
            exit 0
          fi
          git tag -a "$TAG_V" -m "Release $TAG_V"
          git push origin "$TAG_V"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_V: ${{ steps.version.outputs.tag_v }}
          RELEASE_TYPE: ${{ steps.mode.outputs.release_type }}
        run: |
          # idempotent: falls Release existiert -> skip
          if gh release view "$TAG_V" >/dev/null 2>&1; then
            echo "Release $TAG_V existiert bereits – überspringe."
            exit 0
          fi
          gh release create "$TAG_V" \
            --title "Release $TAG_V" \
            --notes "Automatischer ${RELEASE_TYPE}-Release für Drupal Modul."
